
# Application Architecture

Shut Up and Run is built with a modern technology stack designed for scalability, performance, and a rich user experience. This page details the core components and how they interact.

## Core Technologies

*   **Frontend**: [Next.js](https://nextjs.org/) (with React) - A popular framework for building server-rendered and statically generated web applications. It provides features like routing, server components, and image optimization.
*   **UI Components**: [ShadCN UI](https://ui.shadcn.com/) - A collection of beautifully designed, accessible, and customizable UI components built on top of Radix UI and Tailwind CSS.
*   **Styling**: [Tailwind CSS](https://tailwindcss.com/) - A utility-first CSS framework for rapidly building custom user interfaces.
*   **AI Integration**:
    *   [Genkit](https://firebase.google.com/docs/genkit) (from Firebase): An open-source framework designed to help developers build, deploy, and manage AI-powered features.
    *   [Google Gemini](https://deepmind.google/technologies/gemini/): A family of powerful multimodal AI models from Google used for generating content, understanding queries, and more.
*   **Backend & Hosting**: [Firebase](https://firebase.google.com/) - A comprehensive platform from Google providing:
    *   **App Hosting**: For deploying the Next.js application.
    *   **Authentication**: Securely managing user sign-up, sign-in (email/password and anonymous), and user sessions.
    *   **Firestore**: A NoSQL, document-based database for storing user data, training plans, cached content, and feedback.
    *   **Google Cloud Secret Manager**: For securely storing API keys and other sensitive configuration needed by the backend.
*   **External Services**:
    *   **OpenWeatherMap API**: For fetching real-time weather data.
    *   **Google Custom Search API**: For fetching relevant running news.

## Component Breakdown

Here's how the main parts of Shut Up and Run work together:

1.  **Client-Side Application (Next.js Frontend)**
    *   **Location**: `/src/app`, `/src/components`, `/src/hooks`, `/src/lib`
    *   **Responsibilities**:
        *   Renders the user interface that users interact with.
        *   Manages client-side state and routing.
        *   Communicates with Firebase for authentication and data retrieval/storage (via Firestore).
        *   Makes requests to server-side Next.js API routes or directly to Genkit flows (if configured as Next.js handlers) for AI-powered features.
        *   Uses `next/image` for optimized image delivery.
        *   Presents data fetched from various sources in a user-friendly way on the dashboard, profile, and training plan pages.

2.  **AI Layer (Genkit & Gemini)**
    *   **Location**: `/src/ai/flows`, `/src/ai/tools`
    *   **Responsibilities**:
        *   **Genkit Flows**: These are server-side functions that orchestrate AI interactions. Examples include:
            *   `generateDashboardContent`: Aggregates data from weather, news (via tools), user profile, and today's workout to create the main dashboard view.
            *   `generateTrainingPlan`: Creates personalized training schedules based on user inputs.
            *   `generateDailyWorkout`: Determines the specific workout for the current day from an active plan.
            *   `suggestWorkoutWhenNoPlan`: Offers workout ideas if no plan is active.
            *   `generateMotivationalPun`: Creates a fun greeting.
        *   **Genkit Tools**: Reusable functions that Genkit flows can call. Examples:
            *   `fetchGoogleRunningNewsTool`: Interacts with the Google Custom Search API.
            *   `generateMotivationalPunTool`: A specialized tool for pun generation.
        *   **Gemini Model**: The underlying Large Language Model (LLM) that Genkit calls to process prompts, generate text, and perform reasoning for the flows.
    *   **Interaction**: Client components (or Next.js server actions/API routes) invoke these Genkit flows. The flows then use Gemini (and tools) to produce the desired output, which is returned to the client.

3.  **Firebase Backend Services**
    *   **Authentication**:
        *   Manages user accounts (email/password, anonymous).
        *   Provides user session management.
    *   **Firestore Database**:
        *   **Collections**:
            *   `/users/{userId}`: Stores user profile information (fitness level, goals, preferences, location, etc.) and a reference (`trainingPlanId`) to their active training plan.
            *   `/trainingPlans/{trainingPlanId}`: Stores detailed training plans generated by the AI, including the raw plan text and metadata.
            *   `/dashboardCache/{userId}`: Caches the generated dashboard content for a user for a specific day to improve performance and reduce redundant AI calls. Includes inputs used for generation to help with invalidation.
            *   `/feedback/{feedbackId}`: Stores user-submitted feedback.
        *   **Security Rules (`firestore.rules`)**: Define access control for the database, ensuring users can only access and modify their own data.
    *   **App Hosting**:
        *   Hosts the Next.js application.
        *   Manages environment variables (including references to secrets in Secret Manager) via `apphosting.yaml`.

4.  **External APIs**
    *   **OpenWeatherMap API**: Accessed via a server action (`fetchDetailedWeather`) to get current and forecast weather data for the user's specified location. The API key is stored securely.
    *   **Google Custom Search API**: Accessed via the `fetchGoogleRunningNewsTool` to get recent running news. API key and CSE ID are stored securely.

## Data Flow Example: Dashboard Loading

1.  User navigates to the Dashboard page (`/dashboard`).
2.  The `DashboardPage` component (`src/app/dashboard/page.tsx`) mounts.
3.  It authenticates the user using `useUser` from Firebase.
4.  It fetches the user's profile data (`userData`) from Firestore.
5.  It attempts to fetch a cached dashboard (`dashboardCache`) for the current day from Firestore.
6.  **Cache Logic**:
    *   If a fresh cache exists (same day, relevant profile settings haven't changed, training plan ID hasn't changed), the cached content is displayed.
    *   Otherwise, the dashboard content is regenerated:
        *   `fetchDetailedWeather` is called to get current weather data.
        *   The user's active training plan (if any) is consulted to determine today's workout (using `generateDailyWorkoutFlow` or `suggestWorkoutWhenNoPlan`).
        *   The `generateDashboardContent` Genkit flow is invoked with all necessary inputs (user info, weather, workout, news preferences).
        *   This flow uses tools (`fetchGoogleRunningNewsTool`, `generateMotivationalPunTool`) and Gemini to generate:
            *   A motivational greeting.
            *   A weather summary and best run time recommendation.
            *   A "dress your run" clothing suggestion.
            *   A list of top news stories.
        *   The generated content is displayed to the user and saved to the `dashboardCache` in Firestore for future loads on the same day.

## Security Considerations

*   **API Keys**: All external API keys are stored securely using Google Cloud Secret Manager and accessed by the Firebase App Hosting backend environment. They are not exposed to the client-side.
*   **Firestore Security Rules**: Rules are in place to prevent unauthorized data access and modification. Users can only manage their own data.
*   **Authentication**: Firebase Authentication handles secure user login and session management.

This architecture aims for a separation of concerns, leveraging specialized services for each part of the application, from UI rendering to AI processing to data storage.

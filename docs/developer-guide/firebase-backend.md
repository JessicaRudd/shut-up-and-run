
# Firebase Backend Guide

Shut Up and Run leverages several Firebase services for its backend functionality, primarily Authentication and Firestore.

## 1. Firebase Authentication

Firebase Authentication provides secure and easy-to-use services to authenticate users.

*   **Providers Enabled**:
    *   **Email/Password**: Allows users to sign up and sign in using their email address and a password.
    *   **Anonymous**: Allows users to use the app without creating a permanent account. Their data is associated with a temporary anonymous user ID.
*   **Integration**:
    *   The client-side Firebase SDK is initialized in `src/firebase/index.ts` and made available through `src/firebase/client-provider.tsx` and custom hooks like `useAuth()`, `useUser()`.
    *   Login, signup, and logout functionalities are implemented in components within `src/components/auth/`.
    *   `AuthGuard` (`src/components/auth/AuthGuard.tsx`) protects routes that require authentication.
*   **User Data**: Basic user profile information (like UID, email) is managed by Firebase Auth. Additional user-specific application data is stored in Firestore (see below).

## 2. Firestore Database

Cloud Firestore is a flexible, scalable NoSQL document database used to store application data.

### Data Model & Collections

The primary Firestore collections are defined in `firebase/backend.json` and implemented via Zod schemas in `src/lib/firebase-schemas.ts`:

1.  **`/users/{userId}`**:
    *   **Schema**: `UserSchema` (`src/lib/firebase-schemas.ts`)
    *   **Purpose**: Stores all information related to a specific user. The document ID is the user's Firebase Auth UID.
    *   **Key Fields**:
        *   `id`: User's UID.
        *   `email`: User's email.
        *   `firstName`, `lastName`: User's name.
        *   `profile`: An embedded object (`UserProfileSchema`) containing:
            *   `fitnessLevel`, `runningExperience`, `goal`, `daysPerWeek`, `preferredLongRunDay`: Core training preferences.
            *   `preferredWorkoutTypes`, `availableTime`, `equipmentAvailable`: Preferences for ad-hoc workout suggestions.
            *   `locationCity`, `weatherUnit`: For weather personalization.
            *   `newsSearchCategories`: Preferences for news content.
        *   `trainingPlanId`: A string ID referencing a document in the `/trainingPlans` collection (their currently active plan). Can be `null`.

2.  **`/trainingPlans/{trainingPlanId}`**:
    *   **Schema**: `TrainingPlanSchema` (`src/lib/firebase-schemas.ts`)
    *   **Purpose**: Stores individual training plans generated for users.
    *   **Key Fields**:
        *   `id`: Unique ID for the training plan (auto-generated by Firestore).
        *   `userId`: The UID of the user this plan belongs to.
        *   `startDate`, `endDate`: Plan duration.
        *   `rawPlanText`: The complete, multi-line text of the training plan as generated by the AI.
        *   `fitnessLevel`, `runningExperience`, `goal`, `daysPerWeek`, `preferredLongRunDay`: A snapshot of the user's preferences at the time of plan generation.

3.  **`/dashboardCache/{userId}`**:
    *   **Schema**: `DashboardCacheSchema` (`src/lib/firebase-schemas.ts`)
    *   **Purpose**: Caches the fully generated dashboard content for a user for a specific day. This improves performance and reduces costs by avoiding redundant AI calls and API fetches. The document ID is the user's UID.
    *   **Key Fields**:
        *   `id`, `userId`: User's UID.
        *   `cacheDate`: The date (YYYY-MM-DD) for which the content is cached.
        *   `greeting`, `weatherSummary`, `workoutForDisplay`, `topStories`, `planEndNotification`, `dressMyRunSuggestion`: The actual content pieces generated by the `generateDashboardContent` flow.
        *   `cachedInputs`: An object storing key user profile settings (like `locationCity`, `weatherUnit`, `newsSearchCategories`, `trainingPlanId`) that were used to generate the cached content. This is used to invalidate the cache if these settings change.

4.  **`/feedback/{feedbackId}`**:
    *   **Schema**: `FeedbackSubmissionSchema` (`src/lib/firebase-schemas.ts`)
    *   **Purpose**: Stores feedback submissions from users.
    *   **Key Fields**:
        *   `id`: Unique ID for the feedback (auto-generated by Firestore).
        *   `userId`: UID of the user if they were logged in.
        *   `userName`, `userEmail`: Name and email if provided in the form.
        *   `feedbackType`: Category of feedback (bug, feature, etc.).
        *   `message`: The feedback content.
        *   `submittedAt`: Timestamp of submission.

### Firestore Security Rules (`firestore.rules`)

Security rules are crucial for protecting your data. The `firestore.rules` file defines who can read, write, update, or delete data in your collections.

**General Principles Applied:**

*   **Users Collection (`/users/{userId}`):**
    *   **Read, Update**: Users can only read and update their own document (`request.auth.uid == userId`).
    *   **Create**: A user can create their own document (e.g., during signup to save initial profile).
    *   **Delete**: Generally disallowed for users to prevent accidental data loss.
*   **Training Plans Collection (`/trainingPlans/{planId}`):**
    *   **Read, Update, Delete**: Users can manage training plans where the `userId` field in the plan document matches their authenticated UID.
    *   **Create**: Users can create new training plans, and the `userId` field in the new document must match their UID.
*   **Dashboard Cache Collection (`/dashboardCache/{userId}`):**
    *   **Read, Update, Create**: Users can only access/modify the cache document where the document ID matches their UID.
    *   **Delete**: Allowed for their own cache document.
*   **Feedback Collection (`/feedback/{feedbackId}`):**
    *   **Create**: Authenticated users can submit (create) feedback.
    *   **Read, Update, Delete**: Disallowed for client-side users to protect feedback integrity and privacy. These operations would typically be done by an admin with privileged server-side access.

**Example Snippet from `firestore.rules` (Conceptual):**
```firestore
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      allow read, update: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
    }
    match /trainingPlans/{planId} {
      allow read, delete: if request.auth != null && get(/databases/$(database)/documents/trainingPlans/$(planId)).data.userId == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && get(/databases/$(database)/documents/trainingPlans/$(planId)).data.userId == request.auth.uid
                      // Ensure userId cannot be changed after creation
                      && request.resource.data.userId == resource.data.userId;
    }
    // ... other collections
  }
}
```
Refer to the actual `firestore.rules` file in the project for the complete and current rules.

### Data Access from the App

*   The application uses custom React hooks `useDoc` and `useCollection` (from `src/firebase/firestore/`) to subscribe to real-time updates from Firestore for individual documents and collections, respectively.
*   These hooks handle loading states, errors, and provide the data to components.
*   For writes (create, update, delete), the app uses non-blocking update functions (`setDocumentNonBlocking`, `updateDocumentNonBlocking`, etc., from `src/firebase/non-blocking-updates.tsx`). This improves perceived performance by not waiting for the database write to complete before updating the UI or continuing execution (though optimistic UI updates might be needed for a seamless experience in some cases).

## 3. Firebase Emulators

For local development, the project is configured to use the Firebase Emulator Suite for:

*   **Auth Emulator**: Simulates Firebase Authentication.
*   **Firestore Emulator**: Simulates Cloud Firestore.
*   **Emulator UI**: Provides a web interface to view and manage data in the emulators, inspect auth users, and see Firestore requests.

Configuration for emulators is in `firebase.json`. The `src/firebase/index.ts` file automatically connects to these emulators when `process.env.NODE_ENV` is not `"production"`.

This Firebase backend setup provides a robust, scalable, and secure foundation for Shut Up and Run's data management and user authentication needs.
